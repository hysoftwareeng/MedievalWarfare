using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;


public class MapGenerator : MonoBehaviour {
	
	public GameObject GrassPrefab;
	public GameObject MeadowPrefab;
	public GameObject TreePrefab;
	public string ipAddress;
	public int port = 25000;
	public bool isServer = true;
	
	private Graph map;
	private List<Tile> unvisited_vertices;
	private System.Random rand = new System.Random();

	public Graph getMap()
	{
		return this.map;
	}

	
	void Start()
	{
		if (isServer) {
			Network.InitializeServer (32, port);
		} else {
			Network.Connect(ipAddress, port);
		}

	}

	void OnServerInitialized()
	{
		GenerateMap ();
	}

	// Use this for initialization
	void GenerateMap () 
	{
		Debug.Log ("Mapgenerator Start()");
		// add tag for selection
		TreePrefab.tag = "Trees";
		MeadowPrefab.tag = "Meadow";
		GrassPrefab.tag = "Grass";

		Tile firstTile = Tile.CreateComponent(new Vector2 (0, 0), gameObject);
		map = new Graph (firstTile, null);
		unvisited_vertices = new List<Tile>();
		unvisited_vertices.Add(firstTile);

		int maxNumberTile = rand.Next (500, 600);
		
		while(map.vertices.Count < maxNumberTile)
		{
			Tile curr = unvisited_vertices[0];

			Tile up = Tile.CreateComponent(new Vector2(curr.point.x-1, curr.point.y), gameObject);
			Tile down =Tile.CreateComponent(new Vector2(curr.point.x-1, curr.point.y), gameObject);
			Tile leftup = Tile.CreateComponent(new Vector2(curr.point.x + 0.5f, curr.point.y + 0.75f), gameObject);
			Tile rightup = Tile.CreateComponent(new Vector2(curr.point.x + 0.5f, curr.point.y - 0.75f), gameObject);
			Tile leftdown = Tile.CreateComponent(new Vector2(curr.point.x - 0.5f, curr.point.y + 0.75f), gameObject);
			Tile rightdown = Tile.CreateComponent(new Vector2(curr.point.x - 0.5f, curr.point.y - 0.75f), gameObject);
			
			unvisited_vertices.RemoveAt(0);
			
			insertTile(curr, up);
			insertTile(curr, down);
			insertTile(curr, leftup);
			insertTile(curr, rightup);
			insertTile(curr, leftdown);
			insertTile(curr, rightdown);
		}

		List<Tile> outerTiles = map.vertices.Where (t => t.neighbours.Count< 6).ToList();

		// the outer tilees were generated by thier neighbors. we need to link them back.
		foreach(Tile curr in outerTiles)
		{
			Tile tmp = map.GetTile(curr.point.x + 1, curr.point.y);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
			tmp = map.GetTile(curr.point.x-1, curr.point.y);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
			tmp = map.GetTile(curr.point.x + 0.5f, curr.point.y + 0.75f);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
			tmp = map.GetTile(curr.point.x + 0.5f, curr.point.y - 0.75f);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
			tmp = map.GetTile(curr.point.x - 0.5f, curr.point.y + 0.75f);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
			tmp = map.GetTile(curr.point.x - 0.5f, curr.point.y - 0.75f);
			
			if(tmp != null)
			{
				curr.addNeighbour(tmp);
			}
			
		}
		int tileRemoved = 0;
		int index = 0, count = 0;

		int tilesToRemove = rand.Next (100, 150);
		while(tileRemoved < tilesToRemove)
		{
			if(count > 10000)
			{
				// avoid infinite loop
				break;
			}

			//its a little tricky here. we want to remove tiles that are on the outer outer, so <4 is more outer
			//than <6.
			List<Tile> sideTiles = map.vertices.Where (t =>t.neighbours.Count<4 ).ToList();

			if(sideTiles.Count == 0)
			{
				count++;
				continue;
			}
			
			index = rand.Next(sideTiles.Count);
			Tile curr = sideTiles[index];
			
			foreach(Tile neighboor in curr.neighbours)
			{
				neighboor.neighbours.Remove(curr);
			}
			
			map.vertices.Remove(curr);
			tileRemoved++;
			
			count++;
		}
		
		foreach(Tile n in map.vertices)
		{
			int probability = rand.Next(0,100);
			if( probability > 0 && probability <= 20)
			{
				GameObject trees = Network.Instantiate(TreePrefab, new Vector3(n.point.x, 0, n.point.y), TreePrefab.transform.rotation, 0) as GameObject;
				//Tile and NetworkView alreadu attached in the scene
				//trees.AddComponent("Tile");
				n.setLandType( LandType.Trees );
				if(n.getColor() == 0 )
				{
					Transform child = trees.transform.Find("Grass");
					child.renderer.material.color = Color.red;
				}
				else if ( n.getColor() == 1 )
				{
					Transform child = trees.transform.Find("Grass");
					child.renderer.material.color = Color.blue;
				}
			}
			else if( probability > 20 && probability <=30)
			{
				GameObject meadow = Network.Instantiate(MeadowPrefab, new Vector3(n.point.x, 0, n.point.y), MeadowPrefab.transform.rotation, 0) as GameObject;
				//meadow.AddComponent("Tile");
				n.setLandType( LandType.Meadow );
				if(n.getColor() == 0 )
				{
					Transform child = meadow.transform.Find("Grass");
					child.renderer.material.color = Color.red;
				}
				else if ( n.getColor() == 1 )
				{
					Transform child = meadow.transform.Find("Grass");
					child.renderer.material.color = Color.blue;
				}
			}
			else
			{
				GameObject grass = Network.Instantiate(GrassPrefab, new Vector3(n.point.x, 0, n.point.y), GrassPrefab.transform.rotation, 0) as GameObject;
				//grass.AddComponent("Tile");
				n.setLandType( LandType.Grass );
				//grass.GetComponent<Tile>().setColor(n.getColor());
				grass.networkView.RPC("setColor", RPCMode.AllBuffered, n.getColor());
				if(n.getColor() == 0 )
				{
					grass.renderer.material.color = Color.red;
					//this.gameObject.networkView.RPC ("printText", RPCMode.AllBuffered, "NetworkMessage: red grass");
				}
				else if ( n.getColor() == 1 )
				{
					grass.renderer.material.color = Color.blue;
				}
			}
		}

		Debug.Log ("Mapgenerator Start() Ended");
		updateTileColor ();
		
	}

	[RPC]
	void printText(string msg){
		Debug.Log (msg);
	}

	void OnConnectedToServer(){
		Debug.Log ("Connected to server");
	}

	void updateTileColor(){
		GameObject[] allObjects = GameObject.FindGameObjectsWithTag("Grass"); 
		foreach (GameObject gob in allObjects) {
			Tile grassTile =gob.GetComponent<Tile>();
			Debug.Log("Color: " + gob.GetComponent<Tile>().getColor () + " (Grass Tile) ");
			if (grassTile.getColor() == 0)
				gob.renderer.material.color = Color.red;
			else if (grassTile.getColor()==1)
				gob.renderer.material.color = Color.blue;

		}
	}


	// Update is called once per frame
	void Update () {
		updateTileColor ();
	}

	public void initializeVillagesOnMap(Game game)
	{
		List<Player> participants = game.getPlayers();
		foreach ( Tile t in map.vertices )
		{
			if ( t.getVisited() == false )
			{
				List<Tile> TilesToReturn = new List<Tile>();
				BFS( t, TilesToReturn, t.getColor() );
				if( TilesToReturn.Count >= 3 )
				{

					Player p = participants[t.getColor()];
					int num = rand.Next(0, TilesToReturn.Count - 1);
					Tile location = TilesToReturn[num];
					Village newVillage = Village.CreateComponent(p, TilesToReturn, location, gameObject);
					newVillage.addGold( 7 );
					p.addVillage( newVillage );

				} 
			}
		}
	}

	public void BFS(Tile toSearch, List<Tile> TilesToReturn, int color )
	{
		foreach( Tile n in toSearch.neighbours )
		{
			int tileColor = n.getColor();
			if(tileColor == color)
			{
				n.setVisited( true );
				TilesToReturn.Add(n);
			} 
			BFS(n, TilesToReturn, color);
		}
	}

	private void insertTile(Tile curr, Tile t)
	{
		if(map.addTileUnique(t))
		{
			unvisited_vertices.Add(t);
			curr.addNeighbour(t);
		}
		else
		{
			Tile tmpTile = map.GetTile(t.point.x, t.point.y);
			curr.addNeighbour(tmpTile);
		}
	}
	
}